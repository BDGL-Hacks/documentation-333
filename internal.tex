\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{hyperref}

\setlength{\textheight}{8.5in}
\setlength{\headheight}{.25in}
\setlength{\headsep}{.25in}
\setlength{\topmargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}

\title{PartyUp Internals}
\author{David Gilhooley, Lance Goodridge, Blake Lawson, and Graham Turk}

\begin{document}

\pagestyle{plain}

\maketitle

\section{Overview}

PartyUp is an iOS app written in Swift.
The app's back end is hosted on an Amazon Web Services
EC2 instance running Ubuntu.
The back end is built using the Django web framework and uses
a MySQL database.
PartyUp uses Git for version control and the code for the project is 
hosted on \href{https://github.com/}{GitHub}.
The iOS code and back end code can be found at 
\url{https://github.com/BDGL-Hacks/iOS-333} and
\url{https://github.com/BDGL-Hacks/backend-333} respectively.


\section{Implementation: Front End}

Gonna put more sick graphics here

\section{Implementation: Back End}

Gonna put our sick graphics here \\
I Dont know how much detail we need to go into about how
Django works. Like, do we need to talk about urls.py, settings.py,
models.py, views.py, and etc.?

\subsection{Front End}

Gonna put more sick graphics here

The project's iOS code is written in the Swift programming language in the Xcode development environment. You can build and run the project using one of the simulators in Xcode or by plugging in a registered Apple device. The code design follows the traditional-Model-View Controller design paradigm. On the UI side, we used Xcode?s interface builder tool to create the views the user interacts with. The interface builder generates XML code in the Main.storyboard file, which can be inspected in any text editor.

\bigskip

Each view is linked with a view controller class, which dictates how to render the view and handles user actions. The view controllers interact with model classes to fetch information to display on the screen and to store information the user inputs. The models function as the middlemen between the front and back end: during the creation processes, the models are staging areas before the user completes the event or group; when fetching data, the models test for errors and null values before passing the information to the view controllers.

\bigskip

All model classes call methods of the singleton class PartyUpBackend.swift, which handles information exchange with the backend, including event creation, push notification queries, and group message retrieval. Each method in this class prepares a dictionary of post parameters which is sent via HTTP request to the server through a method called sendPostRequest(). The sendPostRequest() method converts the returned JSON file from the backend to a dictionary object, which it then returns to the caller.

\bigskip

We use a class called DataManager.swift to handle key-value lookups of dictionary objects. All of the data manager?s methods are static and require a dictionary (e.g. an event) as an argument. They return (in proper format) the value associated with whatever key the method name corresponds to. 

\bigskip

Much of the information exchange between view controllers is done in the prepareForSegue() method, called when the user triggers a segue from one view to another. In prepareForSegue(), we determine which segue will be executed and then set any variables of the destination view controller before it displays on screen. As an example, when a user clicks on a table cell in the ?My Events? table, we pass the cell?s associated event dictionary to the event info page?s view controller, where it can render the information accordingly. 

\bigskip

Lance talks about iOS group messaging and push notifications here

\end{document}