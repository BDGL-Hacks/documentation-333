\documentclass[12pt]{article}

\setlength{\textheight}{8.5in}
\setlength{\headheight}{.25in}
\setlength{\headsep}{.25in}
\setlength{\topmargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}

\title{PartyUp Report}
\author{David Gilhooley, Lance Goodridge, Blake Lawson, and Graham Turk}

\begin{document}

\pagestyle{plain}

\maketitle

\section{Motivation} % (fold)
\label{sec:Motivation}
We created PartyUp to provide solutions to many problems that we have found when looking for quick ways to communicate with friends when out at an event or party. We designed the app with the idea that it would allow users to quickly change plans, find where their friends are, and communicate rapidly.

PartyUp's was mainly built to give a user an easy way to plan a night out with friends and keep track of those friends throughout the night. Most social media apps focus on singular events or permanent groups, neither of which are conducive to a party setting.
PartyUp focuses on groups that have gotten together to go to a specific event. Because each group must be tied to at least one event, PartyUp knows when the group should eventually be disbanded. This gives PartyUp groups the ephemeral quality that is currently enjoyed in apps like SnapChat and Yik Yak.

Another thing that was lacking in social event apps is the ability to change plans rapidly. In PartyUp groups are able to quickly add or create a new event, check on the locations of their group-members, and send messages back and forth. This helps the group stay together even when the events around them are changing. 

Party safety is always important, and we we have also taken steps to address this in our app. A group member can quickly see the statuses of the other group members and whether or not they have checked in to the current event. If a user has not checked in, then we can see the last place where the user was going. Single tap 'pings' also allow for groups to quickly send notifications to missing group members.
% section Motivation (end)

\section{Design Decisions} % (fold)
\label{sec:design_decisions}

% section design_decisions (end)

\section{Frontend Design Decisions}

\subsection{Xcode Interface Builder}

We did all of the UI design using Xcode's interface builder tool. The tool allows you to drag and drop UI elements onto a canvas, change color schemes visually, and set layout constraints. Interface builder gave us a clear picture of the app?s aesthetics before it was running on a phone. Perhaps even more useful, interface builder facilitates creating outlets and target-action methods between the view and code. In what was a bizarre experience at first, you can actually drag from a canvas element directly to the source code to generate an outlet variable or action method. 

\bigskip

Despite the usefulness of interface builder, we quickly learned that it is not designed for version control. Without explicit control over the generated code, we frequently ran into nasty merge conflicts in the XML file. Looking back, it's tough to say that doing the UI entirely in code would have been better. Neither of us had experience in Xcode, so it would have been an even steeper learning curve. On the other hand, we would have saved hours spent mulling through lines of code to avoid errors in the storyboard file. 

\bigskip

\subsection{Swift vs. Objective-C}
We knew immediately after deciding to do an iPhone app that we would use the new Swift programming language. Neither members of the frontend team had done iOS development, so we would be learning a new language in any case. We felt that Swift is poised to become the dominant iOS language in the future, and would therefore be important to know if either of us wanted to build another app. In addition, in reading through the documentation, we saw many similarities between Swift and Python, a language we were both familiar with. Swift looked more enjoyable to program in than Objective-C and we realized its potential to be used outside of iOS development for more general programming. This choice proved to have some significant drawbacks, however, that we did not foresee. 

\bigskip

At around the 3-week mark, Apple released an update for Swift that broke every file in our frontend code base. The major update was in how Swift processes ?Optionals,? which handle the absence of a value. In Apple?s words, ?Optionals say either ?there is a value, and it equals x? or ?there isn?t a value at all??. We had not even considered the possibility of a significant language update when we decided on Swift. At the time of the update, it wasn?t much of a problem to fix the code. However, it alerted us to the fact that Swift is still a new and unstable language. As our code base grew, it grew more liable to a change in Swift.

\bigskip

With regards to the Swift vs. Objective-C debate, we underestimated the importance of online resources. For almost any question we arrived at, there were a bevy of Stack Overflow posts with perfect answers in Objective-C, but barely any in Swift. We were sometimes forced to attempt to convert the Objective-C code into Swift, which came with associated difficulties. In retrospect, the language of choice was not as important as we had expected. The majority of challenges we faced came from figuring out the CocoaTouch framework, an abstraction layer that handles gesture recognizers and animation, among other UI features. Though using Swift came with its problems, the code reads nicely and we hope that learning Swift will be valuable for our futures as developers.

\bigskip

\section{Public API}
One of the best decisions our group made was publishing an api in the backend Github repository. The api describes the required post parameter key-value pairs and the contents of the returned JSON file. The documentation allowed the front end team to quickly look up the required parameters of any backend-interfacing method. The key names of the returned JSON were translated into methods in our data manager class, which handles all key-value lookups. The Github wiki page aggregated all of the post urls in one, easily navigable location. There was no need to waste time calling or texting a member of the backend team to find out if it was api/group/create or api/groups/create. In addition, given that the api is not specific to iOS development, having the information available opens the door for development in Android or web.

\bigskip

\section{Moving Forward}

If there were more time, we would have built the group detail pages natively in iOS. When it came down to the last week, we realized that the front end team would not be able to complete some of the views we saw as essential to the app. We were able to solve the problem by loading html, css, and javascript (written by the backend team) directly into some of the views. Though the html pages are fully functional, there is a marked difference in look and feel, as well as a short time delay to make the page request. Perhaps with an extra week, the front end team would have been able to render these views in iOS and keep a consistent feel across the app. 

\bigskip

A next step would be to implement photo uploads on the front end given that the backend already supports it. We had initially planned to do geolocation of group members, but decided to drop that feature for time constraints. In our presentation, we spoke briefly about third party event creation. Thinking about the economic potential of an app like PartyUp, we see event promotion as a major source of revenue. We would implement this feature as a website, giving local businesses and event organizers the ability to create their event online without having to download the app.

\bigskip

\section{What we would have done differently}

If we were to start over, I think we would have chosen a narrower problem to address. From the demos we attended, the most successful ones were those that performed one well-defined task. Though we laid out the target features in our initial design document, there was too much leeway. In addition, we would have picked a technology stack that allowed either the two teams to progress in parallel or one team to help the other in the event of a setback. With their experience in Django and AWS, the backend team was consistently ahead of the front end.

\bigskip

\section{Milestones}

For the first three weeks we stayed right on track with our milestone list. We were able to make significant progress at HackPrinceton, which we treated as a feature-thon for PartyUp. Login, register, event creation, and group creation were completed on schedule on both the backend and the frontend. We ran into some difficulty with push notification and group chat. 

\bigskip

\section{Testing}

Most of the testing was done locally. If the app had been ready earlier, we would have used TestFlight to distribute it to real users for beta testing. Nonetheless, we were able to stress test the backend database with 5,000 users from the Drexel University email list.

\section{Group Reflection}

Building PartyUp was unlike any school project we have ever done. We had complete autonomy over the app, a scary notion at first but one that allowed us to develop our creativity. In our case, delegation of work was essential; the project was simply too big and too complex for any one person to dominate. Two of our group members didn?t have Mac computers, so it they were literally unable to work on iOS portion of the code. Each one of us had to rely on other people, a feature of any real-world software development project. 

\bigskip

\section{Individual Reflections}

\subsection{Graham Turk}

Despite the challenges and frustrations, this was undoubtedly the most valuable experience in my time at Princeton. In the past four years I have made multiple attempts to learn app development but never had the time nor drive to follow through. The sheer quantity of information, without a clear method of learning it, had been a major deterrent to crack into development. I always saw app development as indicative of ?real-world? work, where there is no exact formula for how to tackle each problem. Given my failures to make progress, I questioned if I would be able to succeed in that model. This project proved what I always doubted to be true, that perhaps the best way to learn is to be thrown into an unfamiliar situation and told to ?figure it out.? This time, I was not learning as a hobby. I felt an obligation to my team members to make steady progress each week. And as a result of this unique situation, I was able to prove to myself that I can learn an entirely new skill without a formal set of steps to follow. 

\end{document}
